<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".gen.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# var combinations = InitCombinations(); #>
// Generated by EntityEnumerable.tt (<#=combinations.Count - 1#> `foreach` combinations)

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.ComponentModel;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Entities;

namespace StormiumTeam.Shared.Gen
{
    public static class EntityEnumerableExt
    {
<#
foreach (var categories in combinations) {
    if (!categories.Any())
        continue;
    var mappedCategories    = categories.Select((c, i) => (c: (int)c, i: i));
    var delegateName        = GetDelegateName(categories, false);
    var delegateParameters  = GetDelegateParameters(categories, false);
    var genericTypes        = categories.Any() ? ("<" + Series("T{0}", categories.Length, ", ") + ">") : "";
    var genericConstraints  = GetGenericConstraints(categories);
    var fwdParams           = GetFwdParams(categories, false);
#>
        public static EntityEnumerable<#=delegateName#><#=genericTypes#> ToEnumerator<#=delegateName#><#=genericTypes#>(this ComponentSystemBase system, EntityQuery query, <#=delegateParameters#>)
<#  foreach (var constraint in Smart(genericConstraints)) {#>
            <#=constraint.Value#>
<#  }#>
        { 
            return new EntityEnumerable<#=delegateName#><#=genericTypes#>(system, query, <#=fwdParams#>);
        }
<#
}
#>

<#
foreach (var categories in combinations) {
    if (!categories.Any())
        continue;
    var mappedCategories    = categories.Select((c, i) => (c: (int)c, i: i));
    var delegateName        = GetDelegateName(categories, false);
    var delegateParameters  = GetDelegateParameters(categories, false);
    var genericTypes        = categories.Any() ? ("<" + Series("T{0}", categories.Length, ", ") + ">") : "";
    var genericConstraints  = GetGenericConstraints(categories);
    var enumerableDeclareTypes = GetEnumerableDeclareTypes(categories);
#>
    public unsafe struct EntityEnumerable<#=delegateName#><#=genericTypes#>
<#  foreach (var constraint in Smart(genericConstraints)) {#>
        <#=constraint.Value#>
<#  }#>
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable<#=delegateName#>(ComponentSystemBase system, EntityQuery query, <#=delegateParameters#>)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

<#
    foreach (var (c, i) in mappedCategories)
    {
#>
            <#=string.Format("ChunkComponentType{0}", i)#> = system.<#=AccessFunction[c]#><T<#=i#>>(<#=IsReadOnly[c]#>);
            <#=string.Format("Address{0}", i)#> = <#=GetAddressOf((Category) c)#>(<#=string.Format(FwdParam[(int) c], i)#>);
<#
    }
#>
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

<#
    foreach (var (c, i) in mappedCategories)
    {
#>
                <#=string.Format("ChunkComponentType{0} = this.ChunkComponentType{0}", i)#>,
                <#=string.Format("Address{0} = this.Address{0}", i)#>,
                <#=(c != (int) Category.C ? string.Format("SizeOf{0} = UnsafeUtility.SizeOf<T{0}>()", i) : string.Format("SizeOf{0} = UnsafeUtility.SizeOf<IntPtr>()", i))#>,
<#
    }
#>
            };
        }
<#
    foreach (var (c, i) in mappedCategories)
    {
#>
        private <#=string.Format(EnumerableDeclareType[(int)c], i)#>
        private <#=string.Format(AddressDeclareType[(int)c], i)#>
<#
    }
#>
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
<#
    foreach (var (c, i) in mappedCategories.Where(item => item.c == (int) Category.D))
    {
#>
                    UnsafeUtility.MemCpy((byte*) <#=string.Format("Array{0} + (m_EntityIndex - 1) * SizeOf{0}, Address{0}, SizeOf{0}", i)#>);
<#
    }
#>
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
<#
    foreach (var (c, i) in mappedCategories)
    {
#>
                    Array<#=i#> = m_Item.Chunk.<#=string.Format(ChunkGetArray[c], i)#>;
<#
    }
#>
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
<#
    foreach (var (c, i) in mappedCategories)
    {
#>
                <#=string.Format(ArrayCopy[(int) c], i)#>;
<#
    }
#>
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
<#
    foreach (var (c, i) in mappedCategories)
    {
#>
            public <#=string.Format(EnumeratorDeclareType[(int)c], i)#>
            public <#=string.Format(EnumeratorAddressDeclareType[(int)c], i)#>
            public <#=string.Format(GetArrayType((Category) c), i)#> Array<#=i#>;
            public int SizeOf<#=i#>;
<#
    }
#>
        }
    }
<#}#>
    }
} // namespace Unity.Entities

<#+
enum Category
{
    // note: 'in' is broken in c# (very easy for user to accidentally cause a copy) so we do not
    // include it in the combos we support yet.

    D, // ref ComponentData
    I, // in ComponentData
    C, // class
    B, // IBufferElementData
    K, // in IBufferElementData
    S, // ISharedComponentData
}

static string GetArrayType(Category category)
{
    if (category == Category.C)
        return "ArchetypeChunkComponentObjects<T{0}>";
    if (category == Category.S)
        return "T{0}";
    if (category == Category.B)
        return "BufferAccessor<T{0}>";
    return "void*";
}

static string GetAddressOf(Category category)
{
    if (category == Category.C)
        return "Unsafe.AsPointer";
    return "UnsafeUtility.AddressOf";
}

static string GetDelegateName(Category[] categories, bool hasEntity)
{
    var parts = string.Join("", categories.Select(c => c.ToString()));
    return $"_{(hasEntity ? "E" : "")}{parts}";
}

string[] Param =
{
    "ref T{0} d{0}",               // ref ComponentData
    "in T{0} i{0}",                // in ComponentData
    "ref T{0} c{0}",                   // class
    "ref DynamicBuffer<T{0}> b{0}",    // IBufferElementData
    "in DynamicBuffer<T{0}> k{0}", // in IBufferElementData
    "ref T{0} s{0}",                   // ISharedComponentData
};

string[] FwdParam =
{
    "ref d{0}",               // ref ComponentData
    "ref i{0}",                // in ComponentData
    "ref c{0}",                   // class
    "ref b{0}",    // IBufferElementData
    "ref k{0}", // in IBufferElementData
    "ref s{0}",                   // ISharedComponentData
};

string GetDelegateParameters(Category[] categories, bool hasEntity)
{
    var parts = categories.Select((c, i) => string.Format(Param[(int)c], i));
    if (hasEntity)
        parts = parts.Prepend("Entity entity");
    return string.Join(", ", parts);
}

string[] GenericConstraints =
{
    "where T{0} : struct, IComponentData",       // ref ComponentData
    "where T{0} : struct, IComponentData",       // in ComponentData
    "where T{0} : class",                        // class
    "where T{0} : struct, IBufferElementData",   // IBufferElementData
    "where T{0} : struct, IBufferElementData",   // in IBufferElementData
    "where T{0} : struct, ISharedComponentData", // ISharedComponentData
};

IEnumerable<string> GetGenericConstraints(Category[] categories) =>
    categories.Select((c, i) => string.Format(GenericConstraints[(int)c], i));

string[] AccessFunction =
{
    "GetArchetypeChunkComponentType",       // ref ComponentData
    "GetArchetypeChunkComponentType",       // in ComponentData
    "GetArchetypeChunkComponentType",       // class
    "GetArchetypeChunkBufferType",          // IBufferElementData
    "GetArchetypeChunkBufferType",          // in IBufferElementData
    "GetArchetypeChunkSharedComponentType", // ISharedComponentData
};

static string[] IsReadOnly=
{
    "false", // ref ComponentData
    "true",  // in ComponentData
    "",      // class
    "false", // IBufferElementData
    "true",  // in IBufferElementData
    "",      // ISharedComponentData
};

string[] ChunkGetArray =
{
    "GetNativeArray(ChunkComponentType{0}).GetUnsafePtr()",                  // ref ComponentData
    "GetNativeArray(ChunkComponentType{0}).GetUnsafeReadOnlyPtr()",          // in ComponentData
    "GetComponentObjects(ChunkComponentType{0}, System.EntityManager)",    // class
    "GetBufferAccessor(ChunkComponentType{0})",                              // IBufferElementData
    "GetBufferAccessor(ChunkComponentType{0})",                              // in IBufferElementData
    "GetSharedComponentData(ChunkComponentType{0}, System.EntityManager)", // ISharedComponentData
};

string[] ArrayCopy =
{
    "UnsafeUtility.MemCpy(Address{0}, (byte*) Array{0} + m_EntityIndex * SizeOf{0}, SizeOf{0});", // ref ComponentData
    "UnsafeUtility.MemCpy(Address{0}, (byte*) Array{0} + m_EntityIndex * SizeOf{0}, SizeOf{0});", // in ComponentData
    "var tmp{0} = Array{0}[m_EntityIndex]; Unsafe.CopyBlock(Address{0}, Unsafe.AsPointer(ref tmp{0}), (uint) SizeOf{0});", // class
    "var tmp{0} = Array{0}[m_EntityIndex]; UnsafeUtility.MemCpy(Address{0}, UnsafeUtility.AddressOf(ref tmp{0}), SizeOf{0});", // IBufferElementData
    "UnsafeUtility.MemCpy(Address{0}, (byte*) Array{0} + m_EntityIndex * SizeOf{0}, SizeOf{0});", // in IBufferElementData
    "UnsafeUtility.MemCpy(Address{0}, UnsafeUtility.AddressOf(ref Array{0}), SizeOf{0});", // ISharedComponentData
};

string[] EnumerableDeclareType =
{
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // ref ComponentData
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // in ComponentData
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // class
    "ArchetypeChunkBufferType<T{0}> ChunkComponentType{0};",          // IBufferElementData
    "ArchetypeChunkBufferType<T{0}> ChunkComponentType{0};",          // in IBufferElementData
    "ArchetypeChunkSharedComponentType<T{0}> ChunkComponentType{0};", // ISharedComponentData
};

string[] AddressDeclareType =
{
    "void* Address{0};", // ref ComponentData
    "void* Address{0};", // in ComponentData
    "void* Address{0};", // class
    "void* Address{0};", // IBufferElementData
    "void* Address{0};", // IBufferElementData
    "void* Address{0};", // ISharedComponentData
};

string[] EnumeratorDeclareType =
{
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // ref ComponentData
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // in ComponentData
    "ArchetypeChunkComponentType<T{0}> ChunkComponentType{0};",       // class
    "ArchetypeChunkBufferType<T{0}> ChunkComponentType{0};",          // IBufferElementData
    "ArchetypeChunkBufferType<T{0}> ChunkComponentType{0};",          // in IBufferElementData
    "ArchetypeChunkSharedComponentType<T{0}> ChunkComponentType{0};", // ISharedComponentData
};

string[] EnumeratorAddressDeclareType =
{
    "void* Address{0};", // ref ComponentData
    "void* Address{0};", // in ComponentData
    "void* Address{0};", // class
    "void* Address{0};", // IBufferElementData
    "void* Address{0};", // IBufferElementData
    "void* Address{0};", // ISharedComponentData
};

string GetFwdParams(Category[] categories, bool hasEntity)
{
    var parts = categories.Select((c, i) => string.Format(FwdParam[(int)c], i));
    return string.Join(", ", parts);
}

string GetEnumerableDeclareTypes(Category[] categories)
{
    var parts = categories.Select((c, i) => string.Format(FwdParam[(int)c], i));
    return string.Join("\n", parts);
}

static List<Category[]> InitCombinations()
{
    var combinations = new List<Category[]>();

    GetCombinations(new[] { Category.D, Category.C, Category.B, Category.S }, new Category[0], 1);

    var baseCount = combinations.Count;
    for (int i = 0; i != baseCount; ++i)
        GetCombinations(new[] { Category.D }, combinations[i], 5);
    for (int i = 0; i != baseCount; ++i)
        GetCombinations(new[] { Category.C }, combinations[i], 5);
    for (int i = 0; i != baseCount; ++i)
        GetCombinations(new[] { Category.B }, combinations[i], 5);

    combinations.Insert(0, new Category[0]);

    void GetCombinations(Category[] supported, Category[] parent, int depth)
    {
        for (int i = 0; i != supported.Length; ++i)
        {
            var categories = new Category[parent.Length + 1];
            parent.CopyTo(categories, 0);
            categories[categories.Length - 1] = supported[i];

            combinations.Add(categories);

            if (depth-1 > 0)
                GetCombinations(supported, categories, depth-1);
        }
    }

    return combinations;
}

// misc support utils

class SmartElement<T>
{
    public T Value;
    public int Index;
    public int Count;

    public bool First => Index == 0;
    public bool Last => Index == Count - 1;

    public string IfFirst(string text) => First ? text : "";
    public string IfLast(string text) => Last ? text : "";
}

static IEnumerable<SmartElement<T>> Smart<T>(IEnumerable<T> items)
{
    var list = items.ToList();
    for (var i = 0; i < list.Count; ++i)
        yield return new SmartElement<T> { Value = list[i], Index = i, Count = list.Count };
}

static string Series(string formatString, int count, string separator) =>
    string.Join(separator, Enumerable.Range(0, count).Select(i => string.Format(formatString, i)));
#>
